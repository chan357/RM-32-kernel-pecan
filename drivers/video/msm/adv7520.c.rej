--- drivers/video/msm/adv7520.c
+++ drivers/video/msm/adv7520.c
@@ -26,6 +26,7 @@
 #include "hdmi_common.h"
 
 /* #define PORT_DEBUG */
+/* #define HDCP_ENABLE */
 
 static struct hdmi_common_state_type hdmi_common;
 
@@ -43,6 +44,10 @@
 static struct hdmi_data *dd;
 static struct work_struct handle_work;
 
+#ifdef HDCP_ENABLE
+static struct work_struct hdcp_handle_work;
+#endif
+
 static struct timer_list hpd_timer;
 static unsigned int monitor_sense;
 
@@ -259,12 +340,18 @@
 		/* Enable power */
 		/* Clear the power down bit to enable power. */
 		clear_bit(6, &reg0x41);
+
+#ifdef HDCP_ENABLE
+		/* Set for HDCP */
+		reg0xaf = 0x94;
+#else
 		/* Set the HDMI select bit. */
 		set_bit(1, &reg0xaf);
+#endif
 
 		adv7520_write_reg(hclient, 0x41, (u8)reg0x41);
 		adv7520_write_reg(hclient, 0xaf, (u8)reg0xaf);
-		chip_power_on = TRUE ;
+		chip_power_on = TRUE;
 	} else
 		DEV_INFO("%s: chip already has power\n", __func__);
 }
@@ -280,7 +367,7 @@
 		reg0x41 = adv7520_read_reg(hclient, 0x41);
 		set_bit(6, &reg0x41);
 		adv7520_write_reg(hclient, 0x41, (u8)reg0x41);
-		chip_power_on = FALSE ;
+		chip_power_on = FALSE;
 	} else
 		DEV_INFO("%s: chip is already off\n", __func__);
 }
@@ -417,14 +519,21 @@
 
 	/* Set 720p display related registers */
 	reg[0x16] = 0x00;
+
 	reg[0x18] = 0x46;
 	reg[0x55] = 0x00;
+#ifndef HDCP_ENABLE
 	reg[0xba] = 0x60;
+#endif
 	reg[0x3c] = 0x04;
 
-	/* Set Interrupt Mask register for HPD */
+	/* Set Interrupt Mask register for HPD/HDCP */
 	reg[0x94] = 0xC0;
+#ifdef HDCP_ENABLE
+	reg[0x95] = 0xC0;
+#else
 	reg[0x95] = 0x00;
+#endif
 	adv7520_write_reg(hclient, 0x94, reg[0x94]);
 	adv7520_write_reg(hclient, 0x95, reg[0x95]);
 
@@ -485,6 +593,9 @@
 			adv7520_read_edid();
 		} else
 			DEV_DBG("adv7520_timer: EDID TIMEOUT\n");
+#ifdef HDCP_ENABLE
+		adv7520_hdcp_work_queue();
+#endif
 		change_hdmi_state(1);
 	} else {
 		change_hdmi_state(0);
@@ -501,8 +612,17 @@
 static void adv7520_isr(struct work_struct *work)
 {
 	u8 reg0x96 = adv7520_read_reg(hclient, 0x96);
-
+#ifdef HDCP_ENABLE
+	u8 reg0x97 = adv7520_read_reg(hclient, 0x97);
+	DEV_INFO("adv7520_irq: reg[0x96]=%x reg[0x97]=%x\n", reg0x96, reg0x97);
+	/* Clearing the Interrupts */
+	adv7520_write_reg(hclient, 0x97, reg0x97);
+#else
 	DEV_INFO("adv7520_irq: reg[0x96]=%x\n", reg0x96);
+#endif
+	/* Clearing the Interrupts */
+	adv7520_write_reg(hclient, 0x96, reg0x96);
+
 	if ((reg0x96 == 0xC0) || (reg0x96 & 0x40)) {
 		unsigned int hpd_state = adv7520_read_reg(hclient, 0x42);
 		monitor_sense = adv7520_read_reg(hclient, 0xC6);
@@ -522,7 +642,12 @@
 			mod_timer(&hpd_timer, jiffies + 1*HZ);
 		}
 	}
-	adv7520_write_reg(hclient, 0x96, reg0x96);
+#ifdef HDCP_ENABLE
+	if (reg0x97 & 0x80) {
+		DEV_ERR("adv7520_irq: HDCP_ERROR\n",
+		adv7520_close_hdcp_link();
+	}
+#endif
 }
 
 static irqreturn_t adv7520_interrupt(int irq, void *dev_id)
@@ -580,6 +705,9 @@
 
 	INIT_WORK(&dd->work, adv7520_isr);
 	INIT_WORK(&handle_work, adv7520_handle_cable_work);
+#ifdef HDCP_ENABLE
+	INIT_WORK(&hdcp_handle_work, adv7520_hdcp_enable);
+#endif
 	msm_fb_add_device(&hdmi_device);
 	return 0;
 
